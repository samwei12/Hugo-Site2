<!doctype html><html lang=zh-cn dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cocoapods插件机制浅析 | Samwei12's blog</title>
<meta name=keywords content="Cocoapods"><meta name=description content="
原文链接

背景
虽然做iOS开发的过程中使用过 Cocoapods， 但是对里面的细节了解其实不算太多，直到这两年做织女项目时，通过对Cocoapods进行Qt支持改造才开始深入了解部分细节，这个过程中，网上没有找到太多相关资料，本文就简单介绍下我对Cocoapods提供的插件机制的一个简单了解，希望能给大家带来一些帮助。
Ruby Open Classes
在此之前，我们简单看下 Ruby Open Classes ，这部分是为未接触过Ruby的同学准备的，熟悉的同学可以直接略过。
在Ruby中，类永远是开放的，你总是可以将新的方法加入到已有的类中，除了你自己的代码中，还可以用在标准库和内置类中，这个特性被称为Ruby Open Classes。下面我们通过一个示例简单看下。"><meta name=author content><link rel=canonical href=http://localhost:1313/posts/ruby/cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=http://localhost:1313/posts/ruby/cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Cocoapods插件机制浅析"><meta property="og:description" content="
原文链接

背景
虽然做iOS开发的过程中使用过 Cocoapods， 但是对里面的细节了解其实不算太多，直到这两年做织女项目时，通过对Cocoapods进行Qt支持改造才开始深入了解部分细节，这个过程中，网上没有找到太多相关资料，本文就简单介绍下我对Cocoapods提供的插件机制的一个简单了解，希望能给大家带来一些帮助。
Ruby Open Classes
在此之前，我们简单看下 Ruby Open Classes ，这部分是为未接触过Ruby的同学准备的，熟悉的同学可以直接略过。
在Ruby中，类永远是开放的，你总是可以将新的方法加入到已有的类中，除了你自己的代码中，还可以用在标准库和内置类中，这个特性被称为Ruby Open Classes。下面我们通过一个示例简单看下。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/ruby/cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-04T23:16:48+00:00"><meta property="article:modified_time" content="2020-03-04T23:16:48+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cocoapods插件机制浅析"><meta name=twitter:description content="
原文链接

背景
虽然做iOS开发的过程中使用过 Cocoapods， 但是对里面的细节了解其实不算太多，直到这两年做织女项目时，通过对Cocoapods进行Qt支持改造才开始深入了解部分细节，这个过程中，网上没有找到太多相关资料，本文就简单介绍下我对Cocoapods提供的插件机制的一个简单了解，希望能给大家带来一些帮助。
Ruby Open Classes
在此之前，我们简单看下 Ruby Open Classes ，这部分是为未接触过Ruby的同学准备的，熟悉的同学可以直接略过。
在Ruby中，类永远是开放的，你总是可以将新的方法加入到已有的类中，除了你自己的代码中，还可以用在标准库和内置类中，这个特性被称为Ruby Open Classes。下面我们通过一个示例简单看下。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Cocoapods插件机制浅析","item":"http://localhost:1313/posts/ruby/cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cocoapods插件机制浅析","name":"Cocoapods插件机制浅析","description":" 原文链接\n背景 虽然做iOS开发的过程中使用过 Cocoapods， 但是对里面的细节了解其实不算太多，直到这两年做织女项目时，通过对Cocoapods进行Qt支持改造才开始深入了解部分细节，这个过程中，网上没有找到太多相关资料，本文就简单介绍下我对Cocoapods提供的插件机制的一个简单了解，希望能给大家带来一些帮助。\nRuby Open Classes 在此之前，我们简单看下 Ruby Open Classes ，这部分是为未接触过Ruby的同学准备的，熟悉的同学可以直接略过。\n在Ruby中，类永远是开放的，你总是可以将新的方法加入到已有的类中，除了你自己的代码中，还可以用在标准库和内置类中，这个特性被称为Ruby Open Classes。下面我们通过一个示例简单看下。\n","keywords":["Cocoapods"],"articleBody":" 原文链接\n背景 虽然做iOS开发的过程中使用过 Cocoapods， 但是对里面的细节了解其实不算太多，直到这两年做织女项目时，通过对Cocoapods进行Qt支持改造才开始深入了解部分细节，这个过程中，网上没有找到太多相关资料，本文就简单介绍下我对Cocoapods提供的插件机制的一个简单了解，希望能给大家带来一些帮助。\nRuby Open Classes 在此之前，我们简单看下 Ruby Open Classes ，这部分是为未接触过Ruby的同学准备的，熟悉的同学可以直接略过。\n在Ruby中，类永远是开放的，你总是可以将新的方法加入到已有的类中，除了你自己的代码中，还可以用在标准库和内置类中，这个特性被称为Ruby Open Classes。下面我们通过一个示例简单看下。\n首先，我们自定义一个类Human，放在human.rb文件中:\nclass Human def greeting puts \"hello everybody\" end def hungry puts \"I am hungry\" end end 接着，我们新增一个main.rb：\nrequire_relative 'human' john = Human.new john.greeting # hello everybody john.hungry # I am hungry 之后，我们在main.rb中重新定义hungry方法，\nclass Human def hungry puts \"I could eat a horse\" end end john.hungry # I could eat a horse 可以看到，这里在我们新增hungry方法之后，所有的Human类的实例均调用我们的新实现了，即使是已经创建好的实例，这里故意放到两个文件中是想说明这个特性是可以跨文件甚至跨模块的，对Ruby内置方法的替换也是可以的（谨慎使用）\nputs \"hello\".size class String def size puts \"goodbye\" end end # 5 # goodbye puts \"hello\".size 这个特性是十分强大的，让我们可以很容易的对三方模块进行扩展，也是Cocoapods的插件体系所依赖的基础。\n流程分析 Cocoapods的插件体系整体流程还是比较清晰的，下面我们就来逐步看下。\nCLAide 首先，Cocoapods 提供了一个便捷的命令行工具库 CLAide，这个库包含很多功能，例如，一套命令基类，一套插件加载机制等。\nCommand基类 Command基类在lib/claide/command.rb中，这里提供了大量基础功能，包括 run 、 options、 help等等。\n首先，当我们每次执行 pod xxx 命令时候，会执行 bin目录下的可执行文件pod。\nrequire 'cocoapods' if profile_filename = ENV['PROFILE'] # 忽略不相关内容... else Pod::Command.run(ARGV) end 这里实际上是 Pod 模块从CLAide继承了子类Command \u003c CLAide::Command，我们执行Pod命令时候，就会调用\ndef self.run(argv) help! 'You cannot run CocoaPods as root.' if Process.uid == 0 verify_minimum_git_version! verify_xcode_license_approved! super(argv) ensure UI.print_warnings end 实际上只是扩展了一些检测git版本、xcode证书等，真正核心部分还是调用的CLAide的实现：\ndef self.run(argv = []) plugin_prefixes.each do |plugin_prefix| PluginManager.load_plugins(plugin_prefix) end argv = ARGV.coerce(argv) command = parse(argv) ANSI.disabled = !command.ansi_output? unless command.handle_root_options(argv) command.validate! command.run end rescue Object =\u003e exception handle_exception(command, exception) end 可以看到这里真正执行命令之前会遍历所有的插件前缀，并进行插件加载，回过头来再查看 cocoapods/command.rb 会发现，这里指定了约定的插件前缀\nself.plugin_prefixes = %w(claide cocoapods) 可以看到这里的插件分为两种，我们目前只关心文件名为cocoapods前缀的插件。\nPluginManager 我们深入PluginManager的具体实现看下，\ndef self.load_plugins(plugin_prefix) loaded_plugins[plugin_prefix] ||= plugin_gems_for_prefix(plugin_prefix).map do |spec, paths| spec if safe_activate_and_require(spec, paths) end.compact end def self.plugin_gems_for_prefix(prefix) glob = \"#{prefix}_plugin#{Gem.suffix_pattern}\" Gem::Specification.latest_specs(true).map do |spec| matches = spec.matches_for_glob(glob) [spec, matches] unless matches.empty? end.compact end def self.safe_activate_and_require(spec, paths) spec.activate paths.each { |path| require(path) } true # 不相关代码略去 # ... end 为了减小篇幅，这里只贴了核心相关代码，整体的流程大致是：\n调用PluginManager.load_plugins并传入插件前缀 PluginManager.plugin_gems_for_prefix对插件名进行处理，取出我们需要加载的文件，例如cocoapods前缀在这里会转换为所有包含cocoapods_plugin.rb的gem spec 信息及文件信息，例如~/cocoapods-qt/lib/cocoapods_plugin.rb 调用PluginManager.safe_activate_and_require 进行对应的 gem spec 检验并对每个文件进行加载 至此，基本的插件加载流程大致梳理清楚了。\n实操 下面我们看下如何自己扩展一个插件，关于这部分，Cocoapods其实也基本已经帮我们做了很多事情了，主要是 cocoapods-plugins， 它提供了一个插件创建的完整生命周期，包括新增、发布、检索等。\nCocoapods-plugins 执行 pod plugins create cocoapods-test 之后，发现自动帮我们创建了一个gem工程，其中的 lib 文件夹下果然存在了一个 cocoapods_plugin.rb 文件，整体的目录结构如下：\n├── Gemfile ├── LICENSE.txt ├── README.md ├── Rakefile ├── cocoapods-test.gemspec ├── lib │ ├── cocoapods-test │ │ ├── command │ │ │ └── test.rb │ │ ├── command.rb │ │ └── gem_version.rb │ ├── cocoapods-test.rb │ └── **cocoapods_plugin.rb** └── spec ├── command │ └── test_spec.rb └── spec_helper.rb 这里最核心的就是cocoapods_plugin.rb ，我们前面分析过，执行pod命令时候会主动加载所有cocoapods_plugin.rb文件，那么只要我们将需要扩展的类加到这里面，执行命令时候就会生效。\nclass Test \u003c Command self.summary = 'Short description of cocoapods-test.' self.description = \u003c\u003c-DESC Longer description of cocoapods-test. DESC self.arguments = 'NAME' def initialize(argv) @name = argv.shift_argument super end def validate! super help! 'A Pod name is required.' unless @name end def run UI.puts \"Add your implementation for the cocoapods-test plugin in #{__FILE__}\" end end 可以看到这里其实只是新增了一个 Test 命令，并加了一些描述信息。为了让我们的扩展能生效，我们可以通过几种方式，\n本地gem源码依赖 安装gem产物 为了更贴近实际生产发布流程，这里我们采用第二种方式。\n首先，我们编译生成gem产物，\ngem build cocoapods-test.gemspec 其次，本地安装\ngem install ~/CocoapodsQt/cocoapods-test/cocoapods-test-0.0.1.gem --local 此时，我们再执行 pod 命令\n可以看到我们扩展的命令已经生效，接下来就可以开始愉快的coding了。\n结语 至此，我们对Cocoapods的整体插件流程应该有了一个比较清晰的认识了，希望能给大家带来一些帮助。\n","wordCount":"2094","inLanguage":"zh-cn","datePublished":"2020-03-04T23:16:48Z","dateModified":"2020-03-04T23:16:48Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/ruby/cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"},"publisher":{"@type":"Organization","name":"Samwei12's blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Stay hungry, stay foolish. (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Stay hungry, stay foolish.</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Cocoapods插件机制浅析</h1><div class=post-meta><span title='2020-03-04 23:16:48 +0000 UTC'>2020.03.04 23:16:48</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2094 words</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#背景>背景</a><ul><li><a href=#ruby-open-classes>Ruby Open Classes</a></li></ul></li><li><a href=#流程分析>流程分析</a><ul><li><a href=#claide>CLAide</a></li><li><a href=#command基类>Command基类</a></li><li><a href=#pluginmanager>PluginManager</a></li></ul></li><li><a href=#实操>实操</a><ul><li><a href=#cocoapods-plugins>Cocoapods-plugins</a></li></ul></li><li><a href=#结语>结语</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p><a href=http://blog.samwei12.cn/2020/03/04/Ruby/Cocoapods%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/>原文链接</a></p></blockquote><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>虽然做iOS开发的过程中使用过 <strong><a href=https://cocoapods.org/>Cocoapods</a></strong>， 但是对里面的细节了解其实不算太多，直到这两年做织女项目时，通过对Cocoapods进行Qt支持改造才开始深入了解部分细节，这个过程中，网上没有找到太多相关资料，本文就简单介绍下我对Cocoapods提供的插件机制的一个简单了解，希望能给大家带来一些帮助。</p><h3 id=ruby-open-classes>Ruby Open Classes<a hidden class=anchor aria-hidden=true href=#ruby-open-classes>#</a></h3><p>在此之前，我们简单看下 <code>Ruby Open Classes</code> ，这部分是为未接触过Ruby的同学准备的，熟悉的同学可以直接略过。</p><p>在Ruby中，类永远是开放的，你总是可以将新的方法加入到已有的类中，除了你自己的代码中，还可以用在标准库和内置类中，这个特性被称为<code>Ruby Open Classes</code>。下面我们通过一个示例简单看下。</p><p>首先，我们自定义一个类<code>Human</code>，放在<code>human.rb</code>文件中:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>class</span> <span class=nc>Human</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>greeting</span> 
</span></span><span class=line><span class=cl>        <span class=nb>puts</span> <span class=s2>&#34;hello everybody&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hungry</span> 
</span></span><span class=line><span class=cl>        <span class=nb>puts</span> <span class=s2>&#34;I am hungry&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>接着，我们新增一个<code>main.rb</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>require_relative</span> <span class=s1>&#39;human&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>john</span> <span class=o>=</span> <span class=no>Human</span><span class=o>.</span><span class=n>new</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>john</span><span class=o>.</span><span class=n>greeting</span> 
</span></span><span class=line><span class=cl><span class=c1># hello everybody</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>john</span><span class=o>.</span><span class=n>hungry</span>
</span></span><span class=line><span class=cl><span class=c1># I am hungry</span>
</span></span></code></pre></div><p>之后，我们在<code>main.rb</code>中重新定义<code>hungry</code>方法，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>class</span> <span class=nc>Human</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hungry</span> 
</span></span><span class=line><span class=cl>        <span class=nb>puts</span> <span class=s2>&#34;I could eat a horse&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>john</span><span class=o>.</span><span class=n>hungry</span>
</span></span><span class=line><span class=cl><span class=c1># I could eat a horse</span>
</span></span></code></pre></div><p>可以看到，这里在我们新增<code>hungry</code>方法之后，所有的<code>Human</code>类的实例均调用我们的新实现了，即使是已经创建好的实例，这里故意放到两个文件中是想说明这个特性是可以跨文件甚至跨模块的，对Ruby内置方法的替换也是可以的（谨慎使用）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=nb>puts</span> <span class=s2>&#34;hello&#34;</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>String</span> 
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>size</span>
</span></span><span class=line><span class=cl>        <span class=nb>puts</span> <span class=s2>&#34;goodbye&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 5</span>
</span></span><span class=line><span class=cl><span class=c1># goodbye</span>
</span></span><span class=line><span class=cl><span class=nb>puts</span> <span class=s2>&#34;hello&#34;</span><span class=o>.</span><span class=n>size</span>
</span></span></code></pre></div><p>这个特性是十分强大的，让我们可以很容易的对三方模块进行扩展，也是<code>Cocoapods</code>的插件体系所依赖的基础。</p><h2 id=流程分析>流程分析<a hidden class=anchor aria-hidden=true href=#流程分析>#</a></h2><p><code>Cocoapods</code>的插件体系整体流程还是比较清晰的，下面我们就来逐步看下。</p><h3 id=claide>CLAide<a hidden class=anchor aria-hidden=true href=#claide>#</a></h3><p>首先，<code>Cocoapods</code> 提供了一个便捷的命令行工具库 <a href=https://github.com/CocoaPods/CLAide>CLAide</a>，这个库包含很多功能，例如，一套命令基类，一套插件加载机制等。</p><h3 id=command基类>Command基类<a hidden class=anchor aria-hidden=true href=#command基类>#</a></h3><p>Command基类在<code>lib/claide/command.rb</code>中，这里提供了大量基础功能，包括 <code>run</code> 、 <code>options</code>、 <code>help</code>等等。</p><p>首先，当我们每次执行 <code>pod xxx</code> 命令时候，会执行 <code>bin</code>目录下的可执行文件<code>pod</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=nb>require</span> <span class=s1>&#39;cocoapods&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>profile_filename</span> <span class=o>=</span> <span class=no>ENV</span><span class=o>[</span><span class=s1>&#39;PROFILE&#39;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=c1># 忽略不相关内容... </span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=no>Pod</span><span class=o>::</span><span class=no>Command</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=no>ARGV</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>这里实际上是 <code>Pod</code> 模块从<code>CLAide</code>继承了子类<code>Command &lt; CLAide::Command</code>，我们执行Pod命令时候，就会调用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>def</span> <span class=nc>self</span><span class=o>.</span><span class=nf>run</span><span class=p>(</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>help!</span> <span class=s1>&#39;You cannot run CocoaPods as root.&#39;</span> <span class=k>if</span> <span class=no>Process</span><span class=o>.</span><span class=n>uid</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>verify_minimum_git_version!</span>
</span></span><span class=line><span class=cl>    <span class=n>verify_xcode_license_approved!</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>(</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>ensure</span>
</span></span><span class=line><span class=cl>    <span class=no>UI</span><span class=o>.</span><span class=n>print_warnings</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>实际上只是扩展了一些检测git版本、xcode证书等，真正核心部分还是调用的<code>CLAide</code>的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>def</span> <span class=nc>self</span><span class=o>.</span><span class=nf>run</span><span class=p>(</span><span class=n>argv</span> <span class=o>=</span> <span class=o>[]</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>plugin_prefixes</span><span class=o>.</span><span class=n>each</span> <span class=k>do</span> <span class=o>|</span><span class=n>plugin_prefix</span><span class=o>|</span>
</span></span><span class=line><span class=cl>        <span class=no>PluginManager</span><span class=o>.</span><span class=n>load_plugins</span><span class=p>(</span><span class=n>plugin_prefix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>argv</span> <span class=o>=</span> <span class=no>ARGV</span><span class=o>.</span><span class=n>coerce</span><span class=p>(</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>command</span> <span class=o>=</span> <span class=n>parse</span><span class=p>(</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=no>ANSI</span><span class=o>.</span><span class=n>disabled</span> <span class=o>=</span> <span class=o>!</span><span class=n>command</span><span class=o>.</span><span class=n>ansi_output?</span>
</span></span><span class=line><span class=cl>    <span class=k>unless</span> <span class=n>command</span><span class=o>.</span><span class=n>handle_root_options</span><span class=p>(</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>command</span><span class=o>.</span><span class=n>validate!</span>
</span></span><span class=line><span class=cl>        <span class=n>command</span><span class=o>.</span><span class=n>run</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>rescue</span> <span class=no>Object</span> <span class=o>=&gt;</span> <span class=n>exception</span>
</span></span><span class=line><span class=cl>    <span class=n>handle_exception</span><span class=p>(</span><span class=n>command</span><span class=p>,</span> <span class=n>exception</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>可以看到这里真正执行命令之前会遍历所有的插件前缀，并进行插件加载，回过头来再查看 <code>cocoapods/command.rb</code> 会发现，这里指定了约定的插件前缀</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=nb>self</span><span class=o>.</span><span class=n>plugin_prefixes</span> <span class=o>=</span> <span class=sx>%w(claide cocoapods)</span>
</span></span></code></pre></div><p>可以看到这里的插件分为两种，我们目前只关心文件名为<code>cocoapods</code>前缀的插件。</p><h3 id=pluginmanager>PluginManager<a hidden class=anchor aria-hidden=true href=#pluginmanager>#</a></h3><p>我们深入<code>PluginManager</code>的具体实现看下，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>def</span> <span class=nc>self</span><span class=o>.</span><span class=nf>load_plugins</span><span class=p>(</span><span class=n>plugin_prefix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>loaded_plugins</span><span class=o>[</span><span class=n>plugin_prefix</span><span class=o>]</span> <span class=o>||=</span>
</span></span><span class=line><span class=cl>    <span class=n>plugin_gems_for_prefix</span><span class=p>(</span><span class=n>plugin_prefix</span><span class=p>)</span><span class=o>.</span><span class=n>map</span> <span class=k>do</span> <span class=o>|</span><span class=n>spec</span><span class=p>,</span> <span class=n>paths</span><span class=o>|</span>
</span></span><span class=line><span class=cl>        <span class=n>spec</span> <span class=k>if</span> <span class=n>safe_activate_and_require</span><span class=p>(</span><span class=n>spec</span><span class=p>,</span> <span class=n>paths</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span><span class=o>.</span><span class=n>compact</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nc>self</span><span class=o>.</span><span class=nf>plugin_gems_for_prefix</span><span class=p>(</span><span class=n>prefix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>glob</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=si>#{</span><span class=n>prefix</span><span class=si>}</span><span class=s2>_plugin</span><span class=si>#{</span><span class=no>Gem</span><span class=o>.</span><span class=n>suffix_pattern</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=no>Gem</span><span class=o>::</span><span class=no>Specification</span><span class=o>.</span><span class=n>latest_specs</span><span class=p>(</span><span class=kp>true</span><span class=p>)</span><span class=o>.</span><span class=n>map</span> <span class=k>do</span> <span class=o>|</span><span class=n>spec</span><span class=o>|</span>
</span></span><span class=line><span class=cl>        <span class=n>matches</span> <span class=o>=</span> <span class=n>spec</span><span class=o>.</span><span class=n>matches_for_glob</span><span class=p>(</span><span class=n>glob</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>[</span><span class=n>spec</span><span class=p>,</span> <span class=n>matches</span><span class=o>]</span> <span class=k>unless</span> <span class=n>matches</span><span class=o>.</span><span class=n>empty?</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span><span class=o>.</span><span class=n>compact</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nc>self</span><span class=o>.</span><span class=nf>safe_activate_and_require</span><span class=p>(</span><span class=n>spec</span><span class=p>,</span> <span class=n>paths</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>spec</span><span class=o>.</span><span class=n>activate</span>
</span></span><span class=line><span class=cl>    <span class=n>paths</span><span class=o>.</span><span class=n>each</span> <span class=p>{</span> <span class=o>|</span><span class=n>path</span><span class=o>|</span> <span class=nb>require</span><span class=p>(</span><span class=n>path</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kp>true</span>
</span></span><span class=line><span class=cl>    <span class=c1># 不相关代码略去</span>
</span></span><span class=line><span class=cl>    <span class=c1># ...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>为了减小篇幅，这里只贴了核心相关代码，整体的流程大致是：</p><ol><li>调用<code>PluginManager.load_plugins</code>并传入插件前缀</li><li><code>PluginManager.plugin_gems_for_prefix</code>对插件名进行处理，取出我们需要加载的文件，例如<code>cocoapods</code>前缀在这里会转换为所有包含<code>cocoapods_plugin.rb</code>的gem spec 信息及文件信息，例如<code>~/cocoapods-qt/lib/cocoapods_plugin.rb</code></li><li>调用<code>PluginManager.safe_activate_and_require</code> 进行对应的 gem spec 检验并对每个文件进行加载</li></ol><p>至此，基本的插件加载流程大致梳理清楚了。</p><h2 id=实操>实操<a hidden class=anchor aria-hidden=true href=#实操>#</a></h2><p>下面我们看下如何自己扩展一个插件，关于这部分，Cocoapods其实也基本已经帮我们做了很多事情了，主要是 <a href=https://github.com/CocoaPods/cocoapods-plugins>cocoapods-plugins</a>， 它提供了一个插件创建的完整生命周期，包括新增、发布、检索等。</p><h3 id=cocoapods-plugins>Cocoapods-plugins<a hidden class=anchor aria-hidden=true href=#cocoapods-plugins>#</a></h3><p>执行 <code>pod plugins create cocoapods-test</code> 之后，发现自动帮我们创建了一个gem工程，其中的 lib 文件夹下果然存在了一个 <code>cocoapods_plugin.rb</code> 文件，整体的目录结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>├── Gemfile
</span></span><span class=line><span class=cl>├── LICENSE.txt
</span></span><span class=line><span class=cl>├── README.md
</span></span><span class=line><span class=cl>├── Rakefile
</span></span><span class=line><span class=cl>├── cocoapods-test.gemspec
</span></span><span class=line><span class=cl>├── lib
</span></span><span class=line><span class=cl>│   ├── cocoapods-test
</span></span><span class=line><span class=cl>│   │   ├── <span class=nb>command</span>
</span></span><span class=line><span class=cl>│   │   │   └── test.rb
</span></span><span class=line><span class=cl>│   │   ├── command.rb
</span></span><span class=line><span class=cl>│   │   └── gem_version.rb
</span></span><span class=line><span class=cl>│   ├── cocoapods-test.rb
</span></span><span class=line><span class=cl>│   └── **cocoapods_plugin.rb**
</span></span><span class=line><span class=cl>└── spec
</span></span><span class=line><span class=cl>    ├── <span class=nb>command</span>
</span></span><span class=line><span class=cl>    │   └── test_spec.rb
</span></span><span class=line><span class=cl>    └── spec_helper.rb
</span></span></code></pre></div><p>这里最核心的就是<code>cocoapods_plugin.rb</code> ，我们前面分析过，执行pod命令时候会主动加载所有<code>cocoapods_plugin.rb</code>文件，那么只要我们将需要扩展的类加到这里面，执行命令时候就会生效。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>class</span> <span class=nc>Test</span> <span class=o>&lt;</span> <span class=no>Command</span>
</span></span><span class=line><span class=cl>    <span class=nb>self</span><span class=o>.</span><span class=n>summary</span> <span class=o>=</span> <span class=s1>&#39;Short description of cocoapods-test.&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>self</span><span class=o>.</span><span class=n>description</span> <span class=o>=</span> <span class=s>&lt;&lt;-DESC
</span></span></span><span class=line><span class=cl><span class=s></span>        <span class=no>Longer</span> <span class=n>description</span> <span class=n>of</span> <span class=n>cocoapods</span><span class=o>-</span><span class=nb>test</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=no>DESC</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>self</span><span class=o>.</span><span class=n>arguments</span> <span class=o>=</span> <span class=s1>&#39;NAME&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>initialize</span><span class=p>(</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=vi>@name</span> <span class=o>=</span> <span class=n>argv</span><span class=o>.</span><span class=n>shift_argument</span>
</span></span><span class=line><span class=cl>        <span class=k>super</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>validate!</span>
</span></span><span class=line><span class=cl>        <span class=k>super</span>
</span></span><span class=line><span class=cl>        <span class=n>help!</span> <span class=s1>&#39;A Pod name is required.&#39;</span> <span class=k>unless</span> <span class=vi>@name</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>run</span>
</span></span><span class=line><span class=cl>        <span class=no>UI</span><span class=o>.</span><span class=n>puts</span> <span class=s2>&#34;Add your implementation for the cocoapods-test plugin in </span><span class=si>#{</span><span class=bp>__FILE__</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>可以看到这里其实只是新增了一个 <code>Test</code> 命令，并加了一些描述信息。为了让我们的扩展能生效，我们可以通过几种方式，</p><ol><li>本地gem源码依赖</li><li>安装gem产物</li></ol><p>为了更贴近实际生产发布流程，这里我们采用第二种方式。</p><p>首先，我们编译生成gem产物，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gem build cocoapods-test.gemspec
</span></span></code></pre></div><p>其次，本地安装</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gem install ~/CocoapodsQt/cocoapods-test/cocoapods-test-0.0.1.gem  --local
</span></span></code></pre></div><p>此时，我们再执行 pod 命令</p><p><img loading=lazy src=https://img.alicdn.com/tfs/TB1I3Ova8Cw3KVjSZR0XXbcUpXa-2116-1076.jpg alt></p><p>可以看到我们扩展的命令已经生效，接下来就可以开始愉快的coding了。</p><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>至此，我们对Cocoapods的整体插件流程应该有了一个比较清晰的认识了，希望能给大家带来一些帮助。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/cocoapods/>Cocoapods</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/server/jdbc%E5%AD%A6%E4%B9%A0%E4%B8%80/><span class=title>«</span><br><span>JDBC学习一---JDBC入门</span>
</a><a class=next href=http://localhost:1313/posts/ruby/gem/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAcocoapods-%E6%8F%92%E4%BB%B6/><span class=title>»</span><br><span>如何创建一个 Cocoapods 插件</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Samwei12's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>