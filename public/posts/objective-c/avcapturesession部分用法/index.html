<!doctype html><html lang=zh-cn dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AVCaptureSession部分用法 | Samwei12's blog</title>
<meta name=keywords content="AVCaptureSession"><meta name=description content="
原文链接

AVCaptureSession阻塞主线程问题
前阵子程序中出现了一个奇怪的 bug，在 iOS 系统上，页面弹出的时候会卡很久，相机始终黑屏，大概6-7秒钟，跟踪具体每个步骤花费时间的时候发现在viewWillDisappear:中开销最大，这其中只调用了一个相机关闭的代码：
if ([[self.avCameraManager session] isRunning]) {
			[[self.avCameraManager session] stopRunning];
}
仔细看了文档之后，发现问题出在 stopRunning这里，"><meta name=author content><link rel=canonical href=http://localhost:1313/posts/objective-c/avcapturesession%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=http://localhost:1313/posts/objective-c/avcapturesession%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="AVCaptureSession部分用法"><meta property="og:description" content="
原文链接

AVCaptureSession阻塞主线程问题
前阵子程序中出现了一个奇怪的 bug，在 iOS 系统上，页面弹出的时候会卡很久，相机始终黑屏，大概6-7秒钟，跟踪具体每个步骤花费时间的时候发现在viewWillDisappear:中开销最大，这其中只调用了一个相机关闭的代码：
if ([[self.avCameraManager session] isRunning]) {
			[[self.avCameraManager session] stopRunning];
}
仔细看了文档之后，发现问题出在 stopRunning这里，"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/objective-c/avcapturesession%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-09-21T13:58:46+00:00"><meta property="article:modified_time" content="2015-09-21T13:58:46+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="AVCaptureSession部分用法"><meta name=twitter:description content="
原文链接

AVCaptureSession阻塞主线程问题
前阵子程序中出现了一个奇怪的 bug，在 iOS 系统上，页面弹出的时候会卡很久，相机始终黑屏，大概6-7秒钟，跟踪具体每个步骤花费时间的时候发现在viewWillDisappear:中开销最大，这其中只调用了一个相机关闭的代码：
if ([[self.avCameraManager session] isRunning]) {
			[[self.avCameraManager session] stopRunning];
}
仔细看了文档之后，发现问题出在 stopRunning这里，"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"AVCaptureSession部分用法","item":"http://localhost:1313/posts/objective-c/avcapturesession%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AVCaptureSession部分用法","name":"AVCaptureSession部分用法","description":" 原文链接\nAVCaptureSession阻塞主线程问题 前阵子程序中出现了一个奇怪的 bug，在 iOS 系统上，页面弹出的时候会卡很久，相机始终黑屏，大概6-7秒钟，跟踪具体每个步骤花费时间的时候发现在viewWillDisappear:中开销最大，这其中只调用了一个相机关闭的代码：\nif ([[self.avCameraManager session] isRunning]) { [[self.avCameraManager session] stopRunning]; } 仔细看了文档之后，发现问题出在 stopRunning这里，\n","keywords":["AVCaptureSession"],"articleBody":" 原文链接\nAVCaptureSession阻塞主线程问题 前阵子程序中出现了一个奇怪的 bug，在 iOS 系统上，页面弹出的时候会卡很久，相机始终黑屏，大概6-7秒钟，跟踪具体每个步骤花费时间的时候发现在viewWillDisappear:中开销最大，这其中只调用了一个相机关闭的代码：\nif ([[self.avCameraManager session] isRunning]) { [[self.avCameraManager session] stopRunning]; } 仔细看了文档之后，发现问题出在 stopRunning这里，\n苹果文档描述如下：\nClients invoke -stopRunning to stop the flow of data from inputs to outputs connected to the AVCaptureSession instance. This call blocks until the session object has completely stopped.\n重点是这个函数在 session 完全停止下来之前会始终阻塞线程， 同样的，在 startRunning中：\nClients invoke -startRunning to start the flow of data from inputs to outputs connected to the AVCaptureSession instance. This call blocks until the session object has completely started up or failed. A failure to start running is reported through the AVCaptureSessionRuntimeErrorNotification mechanism.\n因此这里必须放在后台线程中处理，否则，就会导致界面不响应，iOS8之后应该在这里做了优化，即使放在主线程做也没有很卡顿的现象，但 iOS7中，尤其是测试设备为4s，界面卡死问题很严重。\n开启和关闭相机部分代码改为：\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ DDLogDebug(@\"Function: %s,line : %d 开启相机\",__FUNCTION__,__LINE__); [[self.avCameraManager session] startRunning]; }); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void) { DDLogDebug(@\"Function: %s,line : %d 关闭相机\",__FUNCTION__,__LINE__); if ([[self.avCameraManager session] isRunning]) { [[self.avCameraManager session] stopRunning]; } }); 这里除了使用系统提供的队列以外还可以自己创建 FIFO 类型后台线程进行管理，包括切换前后摄像头、改变闪光灯模式、切换拍照和录像等，都可以放入子线程操作。\n相机前后台切换问题 另一个问题与前后台切花相关，项目中在程序进入后台时有这么一段代码：\n[self performSelector:@selector(startRunningSession) withObject:nil afterDelay:0.5]; 当时我很奇怪，这里为什么要加延时呢？进入到前台时不是应该直接开启相机吗？于是我直接把这里改成了：\n[self startRunningSession]; 没过多久，问题出现了，多次切换前后台之后发现，相机始终黑屏，这时，进入后台再回来，问题解决了，仔细加了 log 之后发现，出现黑屏的时候，确实也正确调用了启动 session，但是并没有收到系统相机启动成功的消息，反而收到了两次相机关闭的通知。\n那么之前代码中加了0.5秒延时的原因也就清楚了，是为了等待系统关闭相机之后，再调用开启相机，以免相机启动失败，但这种方式真的合理吗？其实并没有解决本质问题，如果0.5秒钟的时间并没有完全关闭系统相机呢？这里仍然会出现黑屏问题。\n于是继续查看系统文档，发现系统的 sampleCode AVCam-iOS中并没有专门用于前后台处理的逻辑，原来这里并不需要我们自己手动管理相机，系统会自动根据程序状态来判断是否需要关闭或者开启相机，如果按 home 进入UIApplicationStateBackground 状态，那么系统自动关闭相机并在进入UIApplicationStateActive状态时开启相机；如果是进入UIApplicationStateInactive状态，例如，双击 home 调出任务管理器，这时，相机并没有被关闭，仍然能够看到 preview 画面。\n我们在程序切换前后台时，仅需要捕获相继开启或者关闭的通知来刷新界面即可，否则可能会由于快速开启切换前后台导致系统相机执行命令错乱，无法正确启动相机。\n总结 AVCaptureSession 中绝大部分操作需要在后台线程完成，最好使用一个 FIFO 的队列来进行操作 前后台切换时，无需手动管理 CaptureSession ","wordCount":"1261","inLanguage":"zh-cn","datePublished":"2015-09-21T13:58:46Z","dateModified":"2015-09-21T13:58:46Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/objective-c/avcapturesession%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95/"},"publisher":{"@type":"Organization","name":"Samwei12's blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Stay hungry, stay foolish. (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Stay hungry, stay foolish.</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">AVCaptureSession部分用法</h1><div class=post-meta><span title='2015-09-21 13:58:46 +0000 UTC'>2015.09.21 13:58:46</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;1261 words</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#avcapturesession阻塞主线程问题>AVCaptureSession阻塞主线程问题</a></li><li><a href=#相机前后台切换问题>相机前后台切换问题</a></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p><a href=http://blog.samwei12.cn/2015/09/21/Objective-C/AVCaptureSession%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95/>原文链接</a></p></blockquote><h2 id=avcapturesession阻塞主线程问题>AVCaptureSession阻塞主线程问题<a hidden class=anchor aria-hidden=true href=#avcapturesession阻塞主线程问题>#</a></h2><p>前阵子程序中出现了一个奇怪的 bug，在 iOS 系统上，页面弹出的时候会卡很久，相机始终黑屏，大概6-7秒钟，跟踪具体每个步骤花费时间的时候发现在<code>viewWillDisappear:</code>中开销最大，这其中只调用了一个相机关闭的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=k>if</span> <span class=p>([[</span><span class=nb>self</span><span class=p>.</span><span class=n>avCameraManager</span> <span class=n>session</span><span class=p>]</span> <span class=n>isRunning</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=p>[[</span><span class=nb>self</span><span class=p>.</span><span class=n>avCameraManager</span> <span class=n>session</span><span class=p>]</span> <span class=n>stopRunning</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>仔细看了文档之后，发现问题出在<code> stopRunning</code>这里，</p><p>苹果文档描述如下：</p><blockquote><p>Clients invoke -stopRunning to stop the flow of data from inputs to outputs connected to
the AVCaptureSession instance. This call blocks until the session object has completely
stopped.</p></blockquote><p>重点是这个函数在 session 完全停止下来之前会始终阻塞线程， 同样的，在<code> startRunning</code>中：</p><blockquote><p>Clients invoke -startRunning to start the flow of data from inputs to outputs connected to
the AVCaptureSession instance. This call blocks until the session object has completely
started up or failed. A failure to start running is reported through the AVCaptureSessionRuntimeErrorNotification
mechanism.</p></blockquote><p>因此这里必须放在后台线程中处理，否则，就会导致界面不响应，iOS8之后应该在这里做了优化，即使放在主线程做也没有很卡顿的现象，但 iOS7中，尤其是测试设备为4s，界面卡死问题很严重。</p><p>开启和关闭相机部分代码改为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=n>dispatch_async</span><span class=p>(</span><span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=n>DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=o>^</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>DDLogDebug</span><span class=p>(</span><span class=s>@&#34;Function: %s,line : %d 开启相机&#34;</span><span class=p>,</span><span class=n>__FUNCTION__</span><span class=p>,</span><span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>[[</span><span class=nb>self</span><span class=p>.</span><span class=n>avCameraManager</span> <span class=n>session</span><span class=p>]</span> <span class=n>startRunning</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=p>});</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl><span class=n>dispatch_async</span><span class=p>(</span><span class=n>dispatch_get_global_queue</span><span class=p>(</span><span class=n>DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=o>^</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>DDLogDebug</span><span class=p>(</span><span class=s>@&#34;Function: %s,line : %d 关闭相机&#34;</span><span class=p>,</span><span class=n>__FUNCTION__</span><span class=p>,</span><span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>([[</span><span class=nb>self</span><span class=p>.</span><span class=n>avCameraManager</span> <span class=n>session</span><span class=p>]</span> <span class=n>isRunning</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=p>[[</span><span class=nb>self</span><span class=p>.</span><span class=n>avCameraManager</span> <span class=n>session</span><span class=p>]</span> <span class=n>stopRunning</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>});</span>
</span></span></code></pre></div><p>这里除了使用系统提供的队列以外还可以自己创建 FIFO 类型后台线程进行管理，包括切换前后摄像头、改变闪光灯模式、切换拍照和录像等，都可以放入子线程操作。</p><h2 id=相机前后台切换问题>相机前后台切换问题<a hidden class=anchor aria-hidden=true href=#相机前后台切换问题>#</a></h2><p>另一个问题与前后台切花相关，项目中在程序进入后台时有这么一段代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>[</span><span class=nb>self</span> <span class=nl>performSelector</span><span class=p>:</span><span class=k>@selector</span><span class=p>(</span><span class=n>startRunningSession</span><span class=p>)</span> <span class=nl>withObject</span><span class=p>:</span><span class=nb>nil</span> <span class=nl>afterDelay</span><span class=p>:</span><span class=mf>0.5</span><span class=p>];</span>
</span></span></code></pre></div><p>当时我很奇怪，这里为什么要加延时呢？进入到前台时不是应该直接开启相机吗？于是我直接把这里改成了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>[</span><span class=nb>self</span> <span class=n>startRunningSession</span><span class=p>];</span>
</span></span></code></pre></div><p>没过多久，问题出现了，多次切换前后台之后发现，相机始终黑屏，这时，进入后台再回来，问题解决了，仔细加了 log 之后发现，出现黑屏的时候，确实也正确调用了启动 session，但是并没有收到系统相机启动成功的消息，反而收到了两次相机关闭的通知。</p><p>那么之前代码中加了0.5秒延时的原因也就清楚了，是为了等待系统关闭相机之后，再调用开启相机，以免相机启动失败，但这种方式真的合理吗？其实并没有解决本质问题，如果0.5秒钟的时间并没有完全关闭系统相机呢？这里仍然会出现黑屏问题。</p><p>于是继续查看系统文档，发现系统的 sampleCode AVCam-iOS中并没有专门用于前后台处理的逻辑，原来这里并不需要我们自己手动管理相机，系统会自动根据程序状态来判断是否需要关闭或者开启相机，如果按 home 进入<code>UIApplicationStateBackground</code> 状态，那么系统自动关闭相机并在进入<code>UIApplicationStateActive</code>状态时开启相机；如果是进入<code>UIApplicationStateInactive</code>状态，例如，双击 home 调出任务管理器，这时，相机并没有被关闭，仍然能够看到 preview 画面。</p><p>我们在程序切换前后台时，仅需要捕获相继开启或者关闭的通知来刷新界面即可，否则可能会由于快速开启切换前后台导致系统相机执行命令错乱，无法正确启动相机。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><ul><li>AVCaptureSession 中绝大部分操作需要在后台线程完成，最好使用一个 FIFO 的队列来进行操作</li><li>前后台切换时，无需手动管理 CaptureSession</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/avcapturesession/>AVCaptureSession</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/objective-c/uitabbarcontroller-state-preservation/><span class=title>«</span><br><span>如何实现 UITabbarController 的 State Preservation?</span>
</a><a class=next href=http://localhost:1313/posts/objective-c/%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88uiview%E5%8A%A8%E7%94%BB/><span class=title>»</span><br><span>如何取消 UIView 动画？</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Samwei12's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>