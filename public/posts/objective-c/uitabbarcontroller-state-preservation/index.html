<!doctype html><html lang=zh-cn dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何实现 UITabbarController 的 State Preservation? | Samwei12's blog</title>
<meta name=keywords content="UITabbarController"><meta name=description content="
原文链接

最近在看ios programming - the big nerd ranch guide 这本书,其中第24章介绍了如何使用系统接口来实现 State Restoration. 示例部分介绍的是如何针对 UINavigationController 来进行保存和还原状态, 然后额外的练习题部分是 UITabbarController 的状态保存和恢复,可是在这里却一直遇到问题， 导致程序返回时UITabbarController始终无法还原状态，本文记录下如何使用State Restoration和UITabbarController所需的额外处理。"><meta name=author content><link rel=canonical href=http://localhost:1313/posts/objective-c/uitabbarcontroller-state-preservation/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=http://localhost:1313/posts/objective-c/uitabbarcontroller-state-preservation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="如何实现 UITabbarController 的 State Preservation?"><meta property="og:description" content="
原文链接

最近在看ios programming - the big nerd ranch guide 这本书,其中第24章介绍了如何使用系统接口来实现 State Restoration. 示例部分介绍的是如何针对 UINavigationController 来进行保存和还原状态, 然后额外的练习题部分是 UITabbarController 的状态保存和恢复,可是在这里却一直遇到问题， 导致程序返回时UITabbarController始终无法还原状态，本文记录下如何使用State Restoration和UITabbarController所需的额外处理。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/objective-c/uitabbarcontroller-state-preservation/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-01-19T21:58:07+00:00"><meta property="article:modified_time" content="2016-01-19T21:58:07+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何实现 UITabbarController 的 State Preservation?"><meta name=twitter:description content="
原文链接

最近在看ios programming - the big nerd ranch guide 这本书,其中第24章介绍了如何使用系统接口来实现 State Restoration. 示例部分介绍的是如何针对 UINavigationController 来进行保存和还原状态, 然后额外的练习题部分是 UITabbarController 的状态保存和恢复,可是在这里却一直遇到问题， 导致程序返回时UITabbarController始终无法还原状态，本文记录下如何使用State Restoration和UITabbarController所需的额外处理。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"如何实现 UITabbarController 的 State Preservation?","item":"http://localhost:1313/posts/objective-c/uitabbarcontroller-state-preservation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何实现 UITabbarController 的 State Preservation?","name":"如何实现 UITabbarController 的 State Preservation?","description":" 原文链接\n最近在看ios programming - the big nerd ranch guide 这本书,其中第24章介绍了如何使用系统接口来实现 State Restoration. 示例部分介绍的是如何针对 UINavigationController 来进行保存和还原状态, 然后额外的练习题部分是 UITabbarController 的状态保存和恢复,可是在这里却一直遇到问题， 导致程序返回时UITabbarController始终无法还原状态，本文记录下如何使用State Restoration和UITabbarController所需的额外处理。\n","keywords":["UITabbarController"],"articleBody":" 原文链接\n最近在看ios programming - the big nerd ranch guide 这本书,其中第24章介绍了如何使用系统接口来实现 State Restoration. 示例部分介绍的是如何针对 UINavigationController 来进行保存和还原状态, 然后额外的练习题部分是 UITabbarController 的状态保存和恢复,可是在这里却一直遇到问题， 导致程序返回时UITabbarController始终无法还原状态，本文记录下如何使用State Restoration和UITabbarController所需的额外处理。\n首先, 我们需要告诉系统我们想要实现状态的保存和恢复, 在 AppDelegate 中实现如下两个方法:\n- (BOOL)application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder { return YES; } - (BOOL)application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder { return YES; } 其次, 我们需要给每个页面赋予一个独有的restorationIdentifier, 两个子页面还需要设置restorationClass, 用于还原状态时重新生成view controller. 代码如下:\nHypnosisViewController *hvc = [HypnosisViewController new]; ReminderViewController *rvc = [ReminderViewController new]; UITabBarController *tabVC = [[UITabBarController alloc] init]; tabVC.viewControllers = @[hvc, rvc]; tabVC.restorationIdentifier = NSStringFromClass([tabVC class]); ... - (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { self.tabBarItem.title = @\"Hypno\"; self.tabBarItem.image = [UIImage imageNamed:@\"Hypno\"]; self.restorationIdentifier = NSStringFromClass([self class]); self.restorationClass = [self class]; } return self; } ... - (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { NSLog(@\"%s line:%d\",__FUNCTION__, __LINE__); self.tabBarItem.title = @\"Reminder\"; self.tabBarItem.image = [UIImage imageNamed:@\"Time\"]; self.restorationIdentifier = NSStringFromClass([self class]); self.restorationClass = [self class]; } return self; } 接着,我们需要在子页面中实现UIViewControllerRestoration协议,同时还要重写 UIViewController自带的用于 Restoration 的两个方法, 下面以HypnosisViewController为例,这里在收到系统需要保存状态消息时,写入当前 textField的值,并且在还原状态时读取,确保用户下次进入程序时仍能还原回之前的场景:\n+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder { UIViewController *vc = [self new]; return vc; } - (void)encodeRestorableStateWithCoder:(NSCoder *)coder { [coder encodeObject:self.textField.text forKey:@\"textField\"]; [super encodeRestorableStateWithCoder:coder]; } - (void)decodeRestorableStateWithCoder:(NSCoder *)coder { self.textField.text = [coder decodeObjectForKey:@\"textField\"]; [super decodeRestorableStateWithCoder:coder]; } 最后, 我们只提供了两个子页面如何进行还原, 还需要处理下 UITabbarController, 如果我们不提供 Controller 的restorationClass属性, 我们可以在application:viewControllerWithRestorationIdentifierPath:coder:中再次处理部分页面的恢复事件,代码如下:\nUIViewController *vc = [UITabBarController new]; vc.restorationIdentifier = [identifierComponents lastObject]; //因为仅当该 Controller 为 UITabbarController 时, identifierComponents数组才会只有一个值 if (identifierComponents.count == 1) { self.window.rootViewController = vc; } return vc; 至此,我们理论上算是已经完成了所有的保存和恢复事件,起码书里面针对UINavigationController的示例代码部分仅包含这些步骤就已经实现了这个功能,那么,UITabbarController是不是一样呢?\n问题 运行程序,为了检验Restoration 的效果,我们进入第二个页面,并且设置一个日期,之后进入后台或者停止调试触发保存事件,当我们再次启动程序时, 可以看到这个页面一闪而过:\n之后就变为了这样:\n事实证明,我们的 UITabbarController 并没有很好地还原为之前的状态,甚至页面变成全空的了,为什么会变成这样呢?\n探究 首先,通过启动程序时的 loading 图可以确定,我们的程序确实已经保存下了之前退出时候的页面状态,后面的白屏证实还原状态这里出了问题,那么即使UITabbarController无法很好地还原,为什么再次启动后会连子页面都不见了呢?\nView Debug 这里, 我们首先想到使用 ios8以后引入的View Debugging来查看 View 层级, 如下图:\n这里我们可以看到, View 层级中,并没有任何子页面,仅仅包含一个 UITabbar 而已,也就是说,我们的两个子页面根本没有添加到 UITabbarController 中, 这又是怎么一回事呢?\n查阅文档 我们看下苹果官方文档对这里是如何描述的:\nIn iOS 6 and later, if you assign a value to this view controller’s restorationIdentifier property, it preserves a reference to the view controller in the selected tab. At restore time, it uses the reference to select the tab with the same view controller.\n看起来好像没有任何问题,只是简单地说了指定 UITabbarController 的restorationIdentifier后,它会记录下当前选中的子页面,然后在下次启动的时候恢复过来. 接着看下去,App Programming Guide for iOS是这么说的:\nAlthough UIKit helps restore the individual view controllers, it does not automatically restore the relationships between those view controllers. Instead, each view controller is responsible for encoding enough state information to return itself to its previous state. For example, a navigation controller encodes information about the order of the view controllers on its navigation stack. It then uses this information later to return those view controllers to their previous positions on the stack. Other view controllers that have embedded child view controllers are similarly responsible for encoding any information they need to restore their children later. Note: Not all view controllers need to encode their child view controllers. For example, tab bar controllers do not encode information about their child view controllers. Instead, it is assumed that your app follows the usual pattern of creating the appropriate child view controllers prior to creating the tab bar controller itself.\n这两段话大致是说, UIKit 虽然帮我们处理了恢复单独页面的事情,但是并不会帮我们恢复页面之间的逻辑关系, 那些包含多个子页面的 Controller 需要自己记录子页面间的逻辑关系并且在恢复时处理它们. 这里还专门说了 UINavigationController 会记录下页面的层级关系并且在再次创建时恢复它,而第二段话说 UITabbarController 却不会记录子页面的顺序, 需要我们自己进行处理. 同时,我们可以在恢复页面时候自行变更 UITabbarController 子页面的顺序.\n解决问题 有了以上知识点,我们就知道了如何还原一个 UITabbarController 页面了,除了赋值restorationIdentifier以外,我们还需要在还原时候自行添加子页面.\nAppDelegate.m\n- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions { self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; // 1. HypnosisViewController *hvc = [HypnosisViewController new]; ReminderViewController *rvc = [ReminderViewController new]; UITabBarController *tabVC = [[UITabBarController alloc] init]; tabVC.viewControllers = @[hvc, rvc]; tabVC.restorationIdentifier = NSStringFromClass([tabVC class]); self.window.rootViewController = tabVC; return YES; } 这样,每次程序启动时,即创建一个新的 UITabbarController, 同时赋予它两个子页面,\n新增了两处代码,用于指定新建的 UITabbarController 的子页面, 之后对两个子页面的+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder方法改动如下:\nHypnosisViewController.m\n+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder { // First object in the array stores the root view controller, which is the tabBarController UITabBarController *rootViewController = (UITabBarController *)[UIApplication sharedApplication].delegate.window.rootViewController; return rootViewController.viewControllers[0]; } ReminderViewController.m\n+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder { // First object in the array stores the root view controller, which is the tabBarController UITabBarController *rootViewController = (UITabBarController *)[UIApplication sharedApplication].delegate.window.rootViewController; return rootViewController.viewControllers[1]; } 用于告诉系统,这两个子页面不需要再次创建,直接返回当前 UITabbarController 子页面即可. 再次运行程序,发现已经能够正常返回到第二个页面了,大功告成!\n扩展 之前文档中有写到, UITabbarController 仅保存了当前选中的页面的指针,而没有保存页面的顺序, 那么,也就是说,我们可以在还原时候重新自定义tab 的顺序, 对代码进行以下改动:\nAppDelegate.md - (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions { ... tabVC.viewControllers = @[rvc, hvc]; ... return YES; } HypnosisViewController.m + (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder { ... return rootViewController.viewControllers[1]; } ReminderViewController.m + (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder { ... return rootViewController.viewControllers[0]; } 再次运行, 得到:\n我们成功的在还原页面状态时候变更了页面顺序,而且UITabbarController 仍然选中为之前保存的状态, 大功告成!\n参考文档 UITabBarController Class Reference Help needed for silver challenge App Programming Guide for iOS http://aplus.rs/2013/state-restoration-in-ios-6-without-storyboards/ ","wordCount":"2343","inLanguage":"zh-cn","datePublished":"2016-01-19T21:58:07Z","dateModified":"2016-01-19T21:58:07Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/objective-c/uitabbarcontroller-state-preservation/"},"publisher":{"@type":"Organization","name":"Samwei12's blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Stay hungry, stay foolish. (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Stay hungry, stay foolish.</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">如何实现 UITabbarController 的 State Preservation?</h1><div class=post-meta><span title='2016-01-19 21:58:07 +0000 UTC'>2016.01.19 21:58:07</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2343 words</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#问题>问题</a></li><li><a href=#探究>探究</a><ul><li><a href=#view-debug>View Debug</a></li><li><a href=#查阅文档>查阅文档</a></li></ul></li><li><a href=#解决问题>解决问题</a></li><li><a href=#扩展>扩展</a></li><li><a href=#参考文档>参考文档</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p><a href=http://blog.samwei12.cn/2016/01/19/Objective-C/UITabbarController-State-Preservation/>原文链接</a></p></blockquote><p>最近在看<strong>ios programming - the big nerd ranch guide</strong> 这本书,其中第24章介绍了如何使用系统接口来实现 State Restoration. 示例部分介绍的是如何针对 <code>UINavigationController</code> 来进行保存和还原状态, 然后额外的练习题部分是 <code>UITabbarController</code> 的状态保存和恢复,可是在这里却一直遇到问题， 导致程序返回时<code>UITabbarController</code>始终无法还原状态，本文记录下如何使用State Restoration和<code>UITabbarController</code>所需的额外处理。</p><p>首先, 我们需要告诉系统我们想要实现状态的保存和恢复, 在 AppDelegate 中实现如下两个方法:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>-</span> <span class=p>(</span><span class=kt>BOOL</span><span class=p>)</span><span class=nf>application:</span><span class=p>(</span><span class=n>UIApplication</span> <span class=o>*</span><span class=p>)</span><span class=nv>application</span> <span class=nf>shouldSaveApplicationState:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>YES</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>-</span> <span class=p>(</span><span class=kt>BOOL</span><span class=p>)</span><span class=nf>application:</span><span class=p>(</span><span class=n>UIApplication</span> <span class=o>*</span><span class=p>)</span><span class=nv>application</span> <span class=nf>shouldRestoreApplicationState:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>YES</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其次, 我们需要给每个页面赋予一个独有的<code>restorationIdentifier</code>, 两个子页面还需要设置<code>restorationClass</code>, 用于还原状态时重新生成view controller. 代码如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=n>HypnosisViewController</span> <span class=o>*</span><span class=n>hvc</span> <span class=o>=</span> <span class=p>[</span><span class=n>HypnosisViewController</span> <span class=n>new</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>ReminderViewController</span> <span class=o>*</span><span class=n>rvc</span> <span class=o>=</span> <span class=p>[</span><span class=n>ReminderViewController</span> <span class=n>new</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>UITabBarController</span> <span class=o>*</span><span class=n>tabVC</span> <span class=o>=</span> <span class=p>[[</span><span class=n>UITabBarController</span> <span class=n>alloc</span><span class=p>]</span> <span class=n>init</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>tabVC</span><span class=p>.</span><span class=n>viewControllers</span> <span class=o>=</span> <span class=l>@[</span><span class=n>hvc</span><span class=p>,</span> <span class=n>rvc</span><span class=l>]</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>tabVC</span><span class=p>.</span><span class=n>restorationIdentifier</span> <span class=o>=</span> <span class=n>NSStringFromClass</span><span class=p>([</span><span class=n>tabVC</span> <span class=k>class</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=o>-</span> <span class=p>(</span><span class=kt>instancetype</span><span class=p>)</span><span class=nl>initWithNibName</span><span class=p>:(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=n>nibNameOrNil</span> <span class=nl>bundle</span><span class=p>:(</span><span class=n>NSBundle</span> <span class=o>*</span><span class=p>)</span><span class=n>nibBundleOrNil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>self</span> <span class=o>=</span> <span class=p>[</span><span class=nb>super</span> <span class=nl>initWithNibName</span><span class=p>:</span><span class=n>nibNameOrNil</span> <span class=nl>bundle</span><span class=p>:</span><span class=n>nibBundleOrNil</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nb>self</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>tabBarItem</span><span class=p>.</span><span class=n>title</span> <span class=o>=</span> <span class=s>@&#34;Hypno&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>tabBarItem</span><span class=p>.</span><span class=n>image</span> <span class=o>=</span> <span class=p>[</span><span class=n>UIImage</span> <span class=nl>imageNamed</span><span class=p>:</span><span class=s>@&#34;Hypno&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>restorationIdentifier</span> <span class=o>=</span> <span class=n>NSStringFromClass</span><span class=p>([</span><span class=nb>self</span> <span class=k>class</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>restorationClass</span> <span class=o>=</span> <span class=p>[</span><span class=nb>self</span> <span class=k>class</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>self</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=o>-</span> <span class=p>(</span><span class=kt>instancetype</span><span class=p>)</span><span class=nl>initWithNibName</span><span class=p>:(</span><span class=n>NSString</span> <span class=o>*</span><span class=p>)</span><span class=n>nibNameOrNil</span> <span class=nl>bundle</span><span class=p>:(</span><span class=n>NSBundle</span> <span class=o>*</span><span class=p>)</span><span class=n>nibBundleOrNil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>self</span> <span class=o>=</span> <span class=p>[</span><span class=nb>super</span> <span class=nl>initWithNibName</span><span class=p>:</span><span class=n>nibNameOrNil</span> <span class=nl>bundle</span><span class=p>:</span><span class=n>nibBundleOrNil</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nb>self</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>NSLog</span><span class=p>(</span><span class=s>@&#34;%s line:%d&#34;</span><span class=p>,</span><span class=n>__FUNCTION__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>tabBarItem</span><span class=p>.</span><span class=n>title</span> <span class=o>=</span> <span class=s>@&#34;Reminder&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>tabBarItem</span><span class=p>.</span><span class=n>image</span> <span class=o>=</span> <span class=p>[</span><span class=n>UIImage</span> <span class=nl>imageNamed</span><span class=p>:</span><span class=s>@&#34;Time&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>restorationIdentifier</span> <span class=o>=</span> <span class=n>NSStringFromClass</span><span class=p>([</span><span class=nb>self</span> <span class=k>class</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>restorationClass</span> <span class=o>=</span> <span class=p>[</span><span class=nb>self</span> <span class=k>class</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>self</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>接着,我们需要在子页面中实现<code>UIViewControllerRestoration</code>协议,同时还要重写<code> UIViewController</code>自带的用于 Restoration 的两个方法, 下面以<code>HypnosisViewController</code>为例,这里在收到系统需要保存状态消息时,写入当前<code> textField</code>的值,并且在还原状态时读取,确保用户下次进入程序时仍能还原回之前的场景:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>+</span> <span class=p>(</span><span class=n>UIViewController</span> <span class=o>*</span><span class=p>)</span><span class=nf>viewControllerWithRestorationIdentifierPath:</span><span class=p>(</span><span class=n>NSArray</span> <span class=o>*</span><span class=p>)</span><span class=nv>identifierComponents</span> <span class=nf>coder:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>UIViewController</span> <span class=o>*</span><span class=n>vc</span> <span class=o>=</span> <span class=p>[</span><span class=nb>self</span> <span class=n>new</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>vc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>encodeRestorableStateWithCoder:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>coder</span> <span class=nl>encodeObject</span><span class=p>:</span><span class=nb>self</span><span class=p>.</span><span class=n>textField</span><span class=p>.</span><span class=n>text</span> <span class=nl>forKey</span><span class=p>:</span><span class=s>@&#34;textField&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=nb>super</span> <span class=nl>encodeRestorableStateWithCoder</span><span class=p>:</span><span class=n>coder</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>decodeRestorableStateWithCoder:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>self</span><span class=p>.</span><span class=n>textField</span><span class=p>.</span><span class=n>text</span> <span class=o>=</span> <span class=p>[</span><span class=n>coder</span> <span class=nl>decodeObjectForKey</span><span class=p>:</span><span class=s>@&#34;textField&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=nb>super</span> <span class=nl>decodeRestorableStateWithCoder</span><span class=p>:</span><span class=n>coder</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最后, 我们只提供了两个子页面如何进行还原, 还需要处理下<code> UITabbarController</code>, 如果我们不提供 Controller 的<code>restorationClass</code>属性, 我们可以在<code>application:viewControllerWithRestorationIdentifierPath:coder:</code>中再次处理部分页面的恢复事件,代码如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=n>UIViewController</span> <span class=o>*</span><span class=n>vc</span> <span class=o>=</span> <span class=p>[</span><span class=n>UITabBarController</span> <span class=n>new</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>vc</span><span class=p>.</span><span class=n>restorationIdentifier</span> <span class=o>=</span> <span class=p>[</span><span class=n>identifierComponents</span> <span class=n>lastObject</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>//因为仅当该 Controller 为 UITabbarController 时, identifierComponents数组才会只有一个值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>identifierComponents</span><span class=p>.</span><span class=n>count</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>self</span><span class=p>.</span><span class=n>window</span><span class=p>.</span><span class=n>rootViewController</span> <span class=o>=</span> <span class=n>vc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>vc</span><span class=p>;</span>
</span></span></code></pre></div><p>至此,我们理论上算是已经完成了所有的保存和恢复事件,起码书里面针对<code>UINavigationController</code>的示例代码部分仅包含这些步骤就已经实现了这个功能,那么,<code>UITabbarController</code>是不是一样呢?</p><h2 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h2><p>运行程序,为了检验Restoration 的效果,我们进入第二个页面,并且设置一个日期,之后进入后台或者停止调试触发保存事件,当我们再次启动程序时, 可以看到这个页面一闪而过:</p><p><img loading=lazy src=http://7xlmda.com1.z0.glb.clouddn.com/2016-01-19_22-49-48.png alt></p><p>之后就变为了这样:</p><p><img loading=lazy src=http://7xlmda.com1.z0.glb.clouddn.com/2016-01-19_22-49-13.png alt></p><p>事实证明,我们的 <code>UITabbarController</code> 并没有很好地还原为之前的状态,甚至页面变成全空的了,为什么会变成这样呢?</p><h2 id=探究>探究<a hidden class=anchor aria-hidden=true href=#探究>#</a></h2><p>首先,通过启动程序时的 loading 图可以确定,我们的程序确实已经保存下了之前退出时候的页面状态,后面的白屏证实还原状态这里出了问题,那么即使<code>UITabbarController</code>无法很好地还原,为什么再次启动后会连子页面都不见了呢?</p><h3 id=view-debug>View Debug<a hidden class=anchor aria-hidden=true href=#view-debug>#</a></h3><p>这里, 我们首先想到使用 ios8以后引入的View Debugging来查看 View 层级, 如下图:</p><p><img loading=lazy src=http://7xlmda.com1.z0.glb.clouddn.com/2016-01-20_22-26-09.png alt></p><p>这里我们可以看到, View 层级中,并没有任何子页面,仅仅包含一个 UITabbar 而已,也就是说,我们的两个子页面根本没有添加到 UITabbarController 中, 这又是怎么一回事呢?</p><h3 id=查阅文档>查阅文档<a hidden class=anchor aria-hidden=true href=#查阅文档>#</a></h3><p>我们看下苹果官方文档对这里是如何描述的:</p><blockquote><p>In iOS 6 and later, if you assign a value to this view controller’s restorationIdentifier property, it preserves a reference to the view controller in the selected tab. At restore time, it uses the reference to select the tab with the same view controller.</p></blockquote><p>看起来好像没有任何问题,只是简单地说了指定 UITabbarController 的<code>restorationIdentifier</code>后,它会记录下当前选中的子页面,然后在下次启动的时候恢复过来. 接着看下去,<a href=https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/StrategiesforImplementingYourApp/StrategiesforImplementingYourApp.html>App Programming Guide for iOS</a>是这么说的:</p><blockquote><p>Although UIKit helps restore the individual view controllers, it does not automatically restore the relationships between those view controllers. Instead, each view controller is responsible for encoding enough state information to return itself to its previous state. For example, a navigation controller encodes information about the order of the view controllers on its navigation stack. It then uses this information later to return those view controllers to their previous positions on the stack. Other view controllers that have embedded child view controllers are similarly responsible for encoding any information they need to restore their children later.
Note: Not all view controllers need to encode their child view controllers. For example, tab bar controllers do not encode information about their child view controllers. Instead, it is assumed that your app follows the usual pattern of creating the appropriate child view controllers prior to creating the tab bar controller itself.</p></blockquote><p>这两段话大致是说, UIKit 虽然帮我们处理了恢复单独页面的事情,但是并不会帮我们恢复页面之间的逻辑关系, 那些包含多个子页面的 Controller 需要自己记录子页面间的逻辑关系并且在恢复时处理它们. 这里还专门说了 UINavigationController 会记录下页面的层级关系并且在再次创建时恢复它,而第二段话说 UITabbarController 却不会记录子页面的顺序, 需要我们自己进行处理. 同时,我们可以在恢复页面时候自行变更 UITabbarController 子页面的顺序.</p><h2 id=解决问题>解决问题<a hidden class=anchor aria-hidden=true href=#解决问题>#</a></h2><p>有了以上知识点,我们就知道了如何还原一个 UITabbarController 页面了,除了赋值<code>restorationIdentifier</code>以外,我们还需要在还原时候自行添加子页面.</p><p>AppDelegate.m</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>-</span> <span class=p>(</span><span class=kt>BOOL</span><span class=p>)</span><span class=nf>application:</span><span class=p>(</span><span class=n>UIApplication</span> <span class=o>*</span><span class=p>)</span><span class=nv>application</span> <span class=nf>willFinishLaunchingWithOptions:</span><span class=p>(</span><span class=n>NSDictionary</span> <span class=o>*</span><span class=p>)</span><span class=nv>launchOptions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>self</span><span class=p>.</span><span class=n>window</span> <span class=o>=</span> <span class=p>[[</span><span class=n>UIWindow</span> <span class=n>alloc</span><span class=p>]</span> <span class=nl>initWithFrame</span><span class=p>:[</span><span class=n>UIScreen</span> <span class=n>mainScreen</span><span class=p>].</span><span class=n>bounds</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nb>self</span><span class=p>.</span><span class=n>window</span><span class=p>.</span><span class=n>backgroundColor</span> <span class=o>=</span> <span class=p>[</span><span class=n>UIColor</span> <span class=n>whiteColor</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 1.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HypnosisViewController</span> <span class=o>*</span><span class=n>hvc</span> <span class=o>=</span> <span class=p>[</span><span class=n>HypnosisViewController</span> <span class=n>new</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>ReminderViewController</span> <span class=o>*</span><span class=n>rvc</span> <span class=o>=</span> <span class=p>[</span><span class=n>ReminderViewController</span> <span class=n>new</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>UITabBarController</span> <span class=o>*</span><span class=n>tabVC</span> <span class=o>=</span> <span class=p>[[</span><span class=n>UITabBarController</span> <span class=n>alloc</span><span class=p>]</span> <span class=n>init</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>tabVC</span><span class=p>.</span><span class=n>viewControllers</span> <span class=o>=</span> <span class=l>@[</span><span class=n>hvc</span><span class=p>,</span> <span class=n>rvc</span><span class=l>]</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tabVC</span><span class=p>.</span><span class=n>restorationIdentifier</span> <span class=o>=</span> <span class=n>NSStringFromClass</span><span class=p>([</span><span class=n>tabVC</span> <span class=k>class</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>self</span><span class=p>.</span><span class=n>window</span><span class=p>.</span><span class=n>rootViewController</span> <span class=o>=</span> <span class=n>tabVC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>YES</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样,每次程序启动时,即创建一个新的 UITabbarController, 同时赋予它两个子页面,</p><p>新增了两处代码,用于指定新建的 UITabbarController 的子页面, 之后对两个子页面的<code>+ (UIViewController *)viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder</code>方法改动如下:</p><p>HypnosisViewController.m</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>+</span> <span class=p>(</span><span class=n>UIViewController</span> <span class=o>*</span><span class=p>)</span><span class=nf>viewControllerWithRestorationIdentifierPath:</span><span class=p>(</span><span class=n>NSArray</span> <span class=o>*</span><span class=p>)</span><span class=nv>identifierComponents</span> <span class=nf>coder:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// First object in the array stores the root view controller, which is the tabBarController
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>UITabBarController</span> <span class=o>*</span><span class=n>rootViewController</span> <span class=o>=</span> <span class=p>(</span><span class=n>UITabBarController</span> <span class=o>*</span><span class=p>)[</span><span class=n>UIApplication</span> <span class=n>sharedApplication</span><span class=p>].</span><span class=n>delegate</span><span class=p>.</span><span class=n>window</span><span class=p>.</span><span class=n>rootViewController</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>rootViewController</span><span class=p>.</span><span class=n>viewControllers</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>ReminderViewController.m</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>+</span> <span class=p>(</span><span class=n>UIViewController</span> <span class=o>*</span><span class=p>)</span><span class=nf>viewControllerWithRestorationIdentifierPath:</span><span class=p>(</span><span class=n>NSArray</span> <span class=o>*</span><span class=p>)</span><span class=nv>identifierComponents</span> <span class=nf>coder:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// First object in the array stores the root view controller, which is the tabBarController
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>UITabBarController</span> <span class=o>*</span><span class=n>rootViewController</span> <span class=o>=</span> <span class=p>(</span><span class=n>UITabBarController</span> <span class=o>*</span><span class=p>)[</span><span class=n>UIApplication</span> <span class=n>sharedApplication</span><span class=p>].</span><span class=n>delegate</span><span class=p>.</span><span class=n>window</span><span class=p>.</span><span class=n>rootViewController</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>rootViewController</span><span class=p>.</span><span class=n>viewControllers</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>用于告诉系统,这两个子页面不需要再次创建,直接返回当前 UITabbarController 子页面即可.
再次运行程序,发现已经能够正常返回到第二个页面了,大功告成!</p><h2 id=扩展>扩展<a hidden class=anchor aria-hidden=true href=#扩展>#</a></h2><p>之前文档中有写到, UITabbarController 仅保存了当前选中的页面的指针,而没有保存页面的顺序, 那么,也就是说,我们可以在还原时候重新自定义tab 的顺序, 对代码进行以下改动:</p><ol><li>AppDelegate.md</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>-</span> <span class=p>(</span><span class=kt>BOOL</span><span class=p>)</span><span class=nf>application:</span><span class=p>(</span><span class=n>UIApplication</span> <span class=o>*</span><span class=p>)</span><span class=nv>application</span> <span class=nf>willFinishLaunchingWithOptions:</span><span class=p>(</span><span class=n>NSDictionary</span> <span class=o>*</span><span class=p>)</span><span class=nv>launchOptions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>tabVC</span><span class=p>.</span><span class=n>viewControllers</span> <span class=o>=</span> <span class=l>@[</span><span class=n>rvc</span><span class=p>,</span> <span class=n>hvc</span><span class=l>]</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>YES</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li>HypnosisViewController.m</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>+</span> <span class=p>(</span><span class=n>UIViewController</span> <span class=o>*</span><span class=p>)</span><span class=nf>viewControllerWithRestorationIdentifierPath:</span><span class=p>(</span><span class=n>NSArray</span> <span class=o>*</span><span class=p>)</span><span class=nv>identifierComponents</span> <span class=nf>coder:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>rootViewController</span><span class=p>.</span><span class=n>viewControllers</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=3><li>ReminderViewController.m</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=p>+</span> <span class=p>(</span><span class=n>UIViewController</span> <span class=o>*</span><span class=p>)</span><span class=nf>viewControllerWithRestorationIdentifierPath:</span><span class=p>(</span><span class=n>NSArray</span> <span class=o>*</span><span class=p>)</span><span class=nv>identifierComponents</span> <span class=nf>coder:</span><span class=p>(</span><span class=n>NSCoder</span> <span class=o>*</span><span class=p>)</span><span class=nv>coder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>rootViewController</span><span class=p>.</span><span class=n>viewControllers</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>再次运行, 得到:</p><p><img loading=lazy src=http://7xlmda.com1.z0.glb.clouddn.com/2016-01-20_23-42-29.png alt></p><p>我们成功的在还原页面状态时候变更了页面顺序,而且UITabbarController 仍然选中为之前保存的状态, 大功告成!</p><h2 id=参考文档>参考文档<a hidden class=anchor aria-hidden=true href=#参考文档>#</a></h2><ul><li><a href=https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarController_Class/>UITabBarController Class Reference</a></li><li><a href="http://forums.bignerdranch.com/viewtopic.php?f=505&amp;t=8402">Help needed for silver challenge</a></li><li><a href=https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/StrategiesforImplementingYourApp/StrategiesforImplementingYourApp.html>App Programming Guide for iOS</a></li><li><a href=http://aplus.rs/2013/state-restoration-in-ios-6-without-storyboards/>http://aplus.rs/2013/state-restoration-in-ios-6-without-storyboards/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/uitabbarcontroller/>UITabbarController</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/utilities/mac/mac%E4%B8%8B%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E7%9B%AE%E5%BD%95%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91/><span class=title>«</span><br><span>Mac下如何自动备份目录到七牛云?</span>
</a><a class=next href=http://localhost:1313/posts/objective-c/avcapturesession%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95/><span class=title>»</span><br><span>AVCaptureSession部分用法</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Samwei12's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>